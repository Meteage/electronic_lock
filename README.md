# electronic_lock
STM32

嵌入式MCU产品开发全流程图:
概念与需求 -> 可行性评估 -> 方案设计 -> 硬件开发 -> 软件开发 -> 系统整合与调试 -> 测试验证 -> 试产与认证 -> 量产与维护

1.需求分析
2.方案设计
3.软硬件开发
4.系统整合与调试
5.文档与说明

# 产品名称：基于STM32的智能指纹门锁设计

# 需求分析（个人练手项目，主要目的是学习嵌入式产品开发流程）
1.基础的密码输入 按键输入 6位
2.输入密码的最后一位显示，其他位数用*隐藏
3.支持指纹解锁
4.30秒无操作自动息屏 自动清空输入
5.5次输错密码将锁住输入，需要等待60秒后重新输入，并连接网络通知主人，告知时间

# 方案设计
1.MCU 采用STM32F103C8T6 
2.4*4矩阵输入键盘 8pin普通引脚
3.OLED显示屏 I2C接口
4.指纹模块 不知道
5.ESP8266实现联网 UART串口
6.LED灯 与 蜂鸣器 与 继电器 x

遇到问题：这个模块是确定好了，但是怎么分配引脚呢？
我感觉还是一部分一部分来，比如可以先搭建一个基础的锁的控制，然后再后面再加其他功能

先实现基础的锁的开关，用一个引脚代表锁的开关，LED要表示 系统的运行状态(定时闪烁)，锁的开关状态，绿色是开，红色是关 所以一共是5个引脚

emmm,还是先实现这些模块的驱动吧，比如矩阵扫描的代码，然后是软件I2C实现，搞一下OLED的显示，这个部分用别人写好的库就行

# 日期[2026.2.9]
矩阵扫描的代码:
    今天下午到晚上一直卡在这个矩阵键盘输入的部分，搞了好久，结果一直卡着，而且出现了各种各样奇怪的问题，
最后到头来是因为，输入端口的配置应该是输入下拉，还是自己的电路知识缺乏了，因为输入引脚下拉的话默认是低电平，但是因为有下拉电阻所以当外接高电平时也可以为高电平，但是如果让引脚浮空的话，输入就是不确定的。

# 日期[2026.2.10]
I2C软件编写测试：
    今天来实现软件I2C的代码实现部分，吸取上次引脚的教训，我们今天不犯这种错误，I2C一般两个引脚SLC,SDA，两个引脚都是开
上拉，好的我们先来复习一下STM32的GPIO有哪些模式，我先想想好像有 输出有：推挽 与 开漏之分，接上拉，下拉或者不接，然后输入有上拉，下拉，复用。。
    答案：STM32的GPIO一般有8种工作模式，
    输入：
        浮空输入，电平不确定完全由外部决定;
        上拉输入，默认是高电平，当外部是低电平时为低电平，适合按键一端为GND的情况，
        下拉输入，默认为低电平，当外部为高电平时，为高电平，适合按键一端接VCC的情况，
        模拟输入，关闭数字施密特触发器，给ADC与DAC使用，适合ADC采集电压.
    输出：
        推挽输出，可以直接驱动LED,继电器适合IO控制
        开漏输入，只能拉低，表现高电平要接上拉电阻，适合线与，I2C总线
        复用推挽，PWM，SPI,UART
        复用开漏, I2c..
    I2C时序复习:
    START信号：SCL为高时，SDA线由高到低
    STOP信号：SCL为高时，SDA由低到高
    逻辑1：SCL为高，SDA为高
    逻辑0：SCL为高，SDA为低
    SCL为高电平时采集数据，SDA只能在SLC为低电平时变化
    然后通信过程想教师上课，一主多从，主机主导上课节奏，
    START信号，上课，然后发送地址信息（7位地址+一位方向0是写，1要求回答），按学号叫人，然后ACK等待对方应答，如果应答，从机拉低，则继续下一步骤，.....,最后停止信号，下课
    信号的发送是高位在前，&
# 日期 [2026.2.11]
    终于是完成了软件I2C代码的编写与SSD1306的驱动库的移植了，然后那个HAL_Delay是没有问题的，只是那个OLED初始化需要一下时间等待，我用的网页在线模拟就会更加慢一些。

    接下来思考密码锁的业务逻辑实现，
    1.输入并记录6位密码 多于六位可以让前面删除后面增加，然后需要按下Ent才验证 也可以到六位之后就自动验证，但是这种容易误触发验证，所以暂时用第一个方案
    2.记录错误次数，多于5次需要等待60秒之后才能再次输入
    3.30秒无操作自动清屏
    4.改密码需要双层验证 输入旧密码，输入旧指纹或 输入两个旧密码 或两个 指纹

#日期 [2026.2.12]
    感觉业务太多了，不太好写
    问了小鲸鱼为什么能写好代码，小鲸鱼说我需要认识到“任何事情都不是一下子就发展好的，都是由简单到复杂”，所以不能期望自己一开始就像哪些大神一样写出很完美的代码，而且就连那些大神其实也是由小白开始发展的，就像现在的我一样，所以先降低自己的期望然后大胆地先写一些垃圾代码，只实现最重要的功能，比如让代码能跑起来，能够实现基础的输入，检验，完成这一步之后再考虑下一步，添加其他功能...总之就是先实践，总结经验，再实践，再总结的循环，每次都往前进步一下，不断迭代，然后它推荐我函数的编写最好是原子化，层次化，每个函数只负责单一的功能，不同层次的函数，只调用下层次的函数，组合而不是继承。然后没有思路的时候就先写写伪代码这样先理清思路，因为卡住我的，其实是那种我总觉得有更完美的方法，但是这是一个遍历问题，找出最完美的方法，你得先有能跑的方法，然后比较，如果你什么都没有，那就得先自己写。

    然后今天花个1h写基础的输入->显示->验证->[对;错]先搭出骨架
    (AI真是好用，大时代给于馈赠，哪怕只有一点点，给一个人来说都是巨大的，这就是个体与集体的关系，大集体好了我们才会更加好)
    扫描按键->有按键->响应按键->按键是那种类型 
        1.数字或者#* 存入输入缓存区 显示出来 ok
        2.删除键 完成
        3.清空键 完成
        4.确认键 完成 用字符串比较函数来实现，所以我改了input_buffer与password数组的类型为6+1的char
    然后正确显示Right，显示3秒同时开门，之前关门重置，带LED的提示,错误显示Error，显示3秒然后重置 [16.42]

    下一步做什么？
    做连输错5次后面60秒（测试采用10秒）不允许再次验证了，需要定时器来做
    先简单个错5次就不能再次验证。[17.20]完成
    现在用定时器写这个倒计时



项目概览
项目名称：基于STM32的智能指纹门锁学习原型

核心目标：掌握嵌入式产品开发全流程，而非追求商业级稳定。

核心MCU：STM32F103C8T6 (STM32F1系列，经典、资源适中、资料极多，俗称“蓝色药丸”)

关键外设：指纹模块、矩阵键盘/独立按键、OLED显示屏、Wi-Fi模块（ESP8266）、继电器（模拟锁体）、LED与蜂鸣器（状态指示）。

将需求转化为技术规格：

功能1/2：需要4x4矩阵键盘或12个独立按键 + 0.96寸OLED显示屏(I2C接口)用于交互。

功能3：需要光学或电容指纹模块（如AS608/FPM10A， UART通信）。

功能4：需要定时器实现30秒超时，并控制屏幕背光。

功能5：需要计数器和定时器实现锁止；需要Wi-Fi模块(ESP8266， AT指令UART控制)实现网络通知；需要一个简单的网络服务（如Bark、Server酱或自建HTTP服务器）来接收通知。

软件架构规划：

裸机 (No RTOS)：使用超级循环(while(1)) + 状态机的方式对于初学者更易于理解和调试。

模块划分：

keypad.c/h: 按键驱动与扫描

oled.c/h: 显示驱动与UI界面

fingerprint.c/h: 指纹识别指令封装

wifi.c/h: ESP8266 AT指令封装

lock_logic.c/h: 核心业务逻辑（密码验证、指纹验证、状态管理、定时逻辑）

main.c: 主循环，调度各模块
