# electronic_lock
STM32

嵌入式MCU产品开发全流程图:
概念与需求 -> 可行性评估 -> 方案设计 -> 硬件开发 -> 软件开发 -> 系统整合与调试 -> 测试验证 -> 试产与认证 -> 量产与维护

1.需求分析
2.方案设计
3.软硬件开发
4.系统整合与调试
5.文档与说明

# 产品名称：基于STM32的智能指纹门锁设计

# 需求分析（个人练手项目，主要目的是学习嵌入式产品开发流程）
√ 1.基础的密码输入 按键输入 6位
√2.输入密码的最后一位显示，其他位数用*隐藏
3.支持指纹解锁
√ 4.30秒无操作自动息屏 自动清空输入
√ 5.5次输错密码将锁住输入，需要等待60秒后重新输入，(并连接网络通知主人，告知时间) 
6.修改密码按键F1 进入修改密码的模式 改密码需要双层验证 输入旧密码，输入旧指纹或 输入两个旧密码 或两个 指纹

# 方案设计
1.MCU 采用STM32F103C8T6 
2.4*4矩阵输入键盘 8pin普通引脚
3.OLED显示屏 I2C接口
4.指纹模块 不知道
5.ESP8266实现联网 UART串口
6.LED灯 与 蜂鸣器 与 继电器 x

遇到问题：这个模块是确定好了，但是怎么分配引脚呢？
我感觉还是一部分一部分来，比如可以先搭建一个基础的锁的控制，然后再后面再加其他功能

先实现基础的锁的开关，用一个引脚代表锁的开关，LED要表示 系统的运行状态(定时闪烁)，锁的开关状态，绿色是开，红色是关 所以一共是5个引脚

emmm,还是先实现这些模块的驱动吧，比如矩阵扫描的代码，然后是软件I2C实现，搞一下OLED的显示，这个部分用别人写好的库就行

# 日期[2026.2.9]
矩阵扫描的代码:
    今天下午到晚上一直卡在这个矩阵键盘输入的部分，搞了好久，结果一直卡着，而且出现了各种各样奇怪的问题，
最后到头来是因为，输入端口的配置应该是输入下拉，还是自己的电路知识缺乏了，因为输入引脚下拉的话默认是低电平，但是因为有下拉电阻所以当外接高电平时也可以为高电平，但是如果让引脚浮空的话，输入就是不确定的。

# 日期[2026.2.10]
I2C软件编写测试：
    今天来实现软件I2C的代码实现部分，吸取上次引脚的教训，我们今天不犯这种错误，I2C一般两个引脚SLC,SDA，两个引脚都是开
上拉，好的我们先来复习一下STM32的GPIO有哪些模式，我先想想好像有 输出有：推挽 与 开漏之分，接上拉，下拉或者不接，然后输入有上拉，下拉，复用。。
    答案：STM32的GPIO一般有8种工作模式，
    输入：
        浮空输入，电平不确定完全由外部决定;
        上拉输入，默认是高电平，当外部是低电平时为低电平，适合按键一端为GND的情况，
        下拉输入，默认为低电平，当外部为高电平时，为高电平，适合按键一端接VCC的情况，
        模拟输入，关闭数字施密特触发器，给ADC与DAC使用，适合ADC采集电压.
    输出：
        推挽输出，可以直接驱动LED,继电器适合IO控制
        开漏输入，只能拉低，表现高电平要接上拉电阻，适合线与，I2C总线
        复用推挽，PWM，SPI,UART
        复用开漏, I2c..
    I2C时序复习:
    START信号：SCL为高时，SDA线由高到低
    STOP信号：SCL为高时，SDA由低到高
    逻辑1：SCL为高，SDA为高
    逻辑0：SCL为高，SDA为低
    SCL为高电平时采集数据，SDA只能在SLC为低电平时变化
    然后通信过程想教师上课，一主多从，主机主导上课节奏，
    START信号，上课，然后发送地址信息（7位地址+一位方向0是写，1要求回答），按学号叫人，然后ACK等待对方应答，如果应答，从机拉低，则继续下一步骤，.....,最后停止信号，下课
    信号的发送是高位在前，&

    通过实践，我更好地掌握了软件I2c的时序软件库的编写，也更加深刻了解了I2C通信的过程
# 日期 [2026.2.11]
    终于是完成了软件I2C代码的编写与SSD1306的驱动库的移植了，然后那个HAL_Delay是没有问题的，只是那个OLED初始化需要一下时间等待，我用的网页在线模拟就会更加慢一些。

    接下来思考密码锁的业务逻辑实现，
    1.输入并记录6位密码 多于六位可以让前面删除后面增加，然后需要按下Ent才验证 也可以到六位之后就自动验证，但是这种容易误触发验证，所以暂时用第一个方案
    2.记录错误次数，多于5次需要等待60秒之后才能再次输入
    3.30秒无操作自动清屏
    4.改密码需要双层验证 输入旧密码，输入旧指纹或 输入两个旧密码 或两个 指纹

#日期 [2026.2.12]
    感觉业务太多了，不太好写
    问了小鲸鱼为什么能写好代码，小鲸鱼说我需要认识到“任何事情都不是一下子就发展好的，都是由简单到复杂”，所以不能期望自己一开始就像哪些大神一样写出很完美的代码，而且就连那些大神其实也是由小白开始发展的，就像现在的我一样，所以先降低自己的期望然后大胆地先写一些垃圾代码，只实现最重要的功能，比如让代码能跑起来，能够实现基础的输入，检验，完成这一步之后再考虑下一步，添加其他功能...总之就是先实践，总结经验，再实践，再总结的循环，每次都往前进步一下，不断迭代，然后它推荐我函数的编写最好是原子化，层次化，每个函数只负责单一的功能，不同层次的函数，只调用下层次的函数，组合而不是继承。然后没有思路的时候就先写写伪代码这样先理清思路，因为卡住我的，其实是那种我总觉得有更完美的方法，但是这是一个遍历问题，找出最完美的方法，你得先有能跑的方法，然后比较，如果你什么都没有，那就得先自己写。

    然后今天花个1h写基础的输入->显示->验证->[对;错]先搭出骨架
    (AI真是好用，大时代给于馈赠，哪怕只有一点点，给一个人来说都是巨大的，这就是个体与集体的关系，大集体好了我们才会更加好)
    扫描按键->有按键->响应按键->按键是那种类型 
        1.数字或者#* 存入输入缓存区 显示出来 ok
        2.删除键 完成
        3.清空键 完成
        4.确认键 完成 用字符串比较函数来实现，所以我改了input_buffer与password数组的类型为6+1的char
    然后正确显示Right，显示3秒同时开门，之前关门重置，带LED的提示,错误显示Error，显示3秒然后重置 [16.42]

    下一步做什么？
    做连输错5次后面60秒（测试采用10秒）不允许再次验证了，需要定时器来做，但是小鲸鱼说，采用定时器是属于优化问题，后面再说。
    先简单个错5次就不能再次验证。[17.20]完成 
    这里代表基础1.0版本完成，但是功能还未完全做完，按照小鲸鱼的说法，是先完整，再迭代优化。我们这边确实还没有完整，所以我们需要再添加功能。

    接下来做，30秒自动清屏，为什么选这个，我最终是要做完整个项目的，而且是先完整再优化（优化指的是优化代码的写法），然后先挑简单的来完成，所以先挑任务4，之后做任务6改密码，但是改密码的话，要解决HAL_Delay部分的问题，但是我感觉这个AI分析的不对，应该是需要先解锁再点击改密码部分，但是这个其实是借鉴了手机的做法，如果是密码锁的话它这个其实也是挺好的，行嘛，我对马哲还是不太懂就不乱套公式了，让我先实践看看吧

    已完成了，30秒自动清屏的功能[22.13]

    现在来做任务2部分，这个目前比较简单，而且现在已经22.18，我一会要睡觉了，这个可以加个选项来加入或者不加入方便用来调试
    任务完成[22.48] 分离了调试信息与输入缓存区的显示，然后加了掩码的步骤，可以通过X_Enable控制是否开启掩码，顺便解决了error_count没有在解锁之后清零的bug

    明天来写这个改密码的功能，但是前置工作是把LOCK等待改成非阻塞的

    把 Delay 锁定，改成：
    锁定60秒，屏幕实时显示剩余秒数，按键无效
    60秒后自动解锁，显示 Ready

    任务也是完成了[13.47]

    之后做任务6这个大骨头[13.53 -- 17.30]

    1.想一下思路，按下F1进入 修改密码的状态 首先提示 输入旧密码 然后按下确认键 
        密码是对的 -> 设置新密码 -> 再次设置新密码 
            判断 两次新密码是否相同 
                是 相同设置成功
                否 输出两次密码不一致 清空 重新输入
        密码是错的 -> 退出设置模式 
    按下F2 进入输入模式

    2.改一下输出页面 [14.38-16.22]
        1行 系统状态：Mode:x State:R/L/E 
        2行 提示信息：Input OP/NP1/NP2 again
        3行 输入掩码：   ______

    3.写按下F1的逻辑代码 [16.23-]
    感觉一直写OLED的渲染太烦了，所以把OLED的渲染从按键这边分离，写状态机区分执行功能，然后靠按键来切换状态

    2.9 分离OLED渲染与按键响应 [17.10调整完毕]

    好的，完成拉[17.29]

    接下来做什么呢，其实可以做把密码存到e2rom 里
    所以写EEPROM的存储程序 
        先完成AT24C20 存储器的驱动库 写这个驱动库，一直搞到凌晨两点钟，原因是因为I2C接收部分写出来，当时也没有测试，就直接用来写AT24C02了，结果是有问题的，花了好久时间才发现。。。
    然后就是写指纹模块的驱动[20.35]

